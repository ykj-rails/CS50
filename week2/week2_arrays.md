# [Week2 Arrays](https://cs50.jp/x/2022/week2/)

## 概要

[Week1](/week1/week1_c.md)から引き続きC言語を使用したプログラミングを行う中で配列について学ぶ講義

## コンパイルのステップ

- コマンドを実行する時にボトムアップで何が起こっているか理解することが大切

### preprocessing

- 前処理
- `#include`で始まるものの検索と置換を行う

### compiling

- 前処理されたソースコードをアセンブリ言語と呼ばれるものに変換する

### assembling

- 3番目のステップ
- コンピュータがソースコードから自動的に生成したアセンブリ言語を0と1に変換する

### linking

- バイナリを全てリンクして1つのファイルにまとめる

## デバッグ

### printf

- printfやそれと同等なものを使うことでコンピュータのメモリの中を見ることができる
- 一時的に組み込んでデバッグする

### rubber duck

- 誰かと一緒に問題を解決したり、コードについて話し合ったりすること
- 1人の場合はコードを見ながら声に出す（もしくは非生物に話しかける）
- 頭の中にひらめく瞬間がある

## C言語の型におけるバイト数

- `bool`は厳密には1ビットで良いので少し過剰なものの、コンピュータはわかりやすくするために1バイト丸ごと使っている

```
bool   1byte
char   1byte
double 8bytes
float  4bytes
int    4bytes
long   8bytes
```

## arrays

- C言語の配列は0インデックス
- 配列の目的は複数の変数名を避けるため
- stringは文字の配列

```c
int scores[3];

scores[0] = 72;
scores[1] = 73;
scores[2] = 33;
```

### String

- 文字列は何バイトにもなり得るため、ある文字列と別の文字列をメモリ上で区別するために何らかの方法で線を引く必要がある
- `\n`はコンピューターのメモリ上では1バイトとして保存される

## exit status

- プログラムが成功したかどうかをユーザーに知らせる
- mainの戻り値によって行う
- 慣習としてプログラムに何か問題が発生したらmainから0以外の値を返す
- 明示的に値を返さない場合、mainは自動的に0を返す

```c
int main(int argc, string argv[]) {
	if (argc != 2) {
		printf("Missing command-line argument\n");
		return 1;
	}
	printf("hello, %s\n", argv[1]);
	return 0;
}
```

## 感想

前回の講義から引き続きC言語を使用しながら新たに配列について学ぶ講義であった

私は普段TypeScriptを書いているフロントエンドエンジニアなので配列に関しては一定理解しており、真新しく学ぶことは無かった。

講義の中ではデバッグと車輪の再発明についても言及しており、デバッグにおいては`printf`（フロントエンドなら`console.log`）やラバーダッキングにおけるデバッグ方法を紹介していた。

過去を振り返ると様々なエラーに遭遇してきたが、上記の2つと「疲れたら寝る」という3つの方法で解決してきたことが多かった。

デバッグにおいては「疲れたら寝る」も推しておきたい。

車輪の再発明においては実装に必要な処理を行う言語組み込みの関数があるかドキュメントを確認する重要性を説いており、初学者にとっては非常に有益な情報なので、こういうちょっとしたTipsが散りばめられているところがCS50の良いところだなぁと感じた。
