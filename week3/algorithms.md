# [Week3 Algorithms](https://cs50.jp/x/2022/week3/)

## 概要

探索やソートを通じてアルゴリズムについて学ぶ講義

## running times

- 実行中にどれだけ時間がかかるか

### O（ビッグオー）

- あるアルゴリズムの実行時間の上限を表すのに使われる

### Ω（オメガ）

- あるアルゴリズムの実行時間の下限を表すのに使われる

### θ（シータ）

- あるアルゴリズムの実行時間の上限と下限の両方が同じである場合を表すのに使われる

## linear search（線形探索）

- O(n)
- 数字について何も知らない場合には最良の選択肢
- リストや配列に入ったデータに対する検索を行うにあたって、先頭から順に比較を行い、それが見つかれば終了する。

## binary search（二分探索）

- O(log n)
- ソート済みの配列に対する探索アルゴリズムの一つ
- 中央の値を見て、検索したい値が中央の値の右にあるか左にあるかを判断をして、片側には存在しないことを確かめながら検索する

## data structures

- C言語ではデータ型を自分で実装することができる

```c
typedef struct {
  string name;
  string number;
} person;
```

## selection sort

- 最小の要素を何度も何度も選択肢左から右へ正しい位置に配置する
- ソートをするごとにソート対象のサイズが小さくなる

## bubble sort

- 大きな値が右に泡のように浮き上がる
- 1つ1つを何度も比較して順序が正しくなければ入れ替える
- 配列が全てn個あるとして、最小の値をあるべき位置に持っていくにはn-1歩の移動が必要
- ソートが頻繁に行われるデータの場合はバブルソートが良い

## recursion

- 上記の二つは一般に比較ソートとして知られているが膨大な数の比較を何度も繰り返している
- 数学的なテクニックで「再帰」と呼ばれる、並べ替え問題を根本的に違う方法で解決するためのメンタルモデル

```c
// 自分自身の中で自分自身を呼び出すコードの例

int main(void) {
  int height = get_int("Height: ");
  draw(height);
}

void draw(int n) {
  if (n == 0) {
    return
  }

  draw(n -1);

  for (int i = 0; i < n; i++) {
    printf("#");
  }
  printf("\n");
}
```

## merge sort

- マージの処理に多くのメモリを使うが、メモリを多く使うことで総実行時間が早い

## Comparison Sorting Algorithms

- ソートを視覚化できるツール
- https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 感想

フロントエンドで探索やソートのアルゴリズムを書くことはあまり経験がなく、組み込みの関数を使うことが多かったので、アルゴリズムについての基礎的な知識を学ぶことができた。

探索においては、対象の配列がソートされていない場合には線形探索が最適であり、ソートされている場合には二分探索が最適であることがわかった

ソートにおいては、データ量がそれほど多くないのであれば選択ソートやバブルソートを使うのは合理的で、ソートした結果を他の探索に利用するケースがある場合はソートした方が良い点なども学ぶことができた

一方でデータ量が多い場合においては、マージソートが最適であるもののメモリを多く使う点がデメリットで、メモリリソースが限られた環境では他のアルゴリズムが最適そうだなと感じた

メモリについてはWeek4で学ぶことになるので、そこでさらに理解を深めることができるのが楽しみ

また、講義ではハーバード大の学生に数字が書かれたTシャツを着せ、生徒を動かしながら配列のソートに関しての説明をしている点がユニークで面白かった



